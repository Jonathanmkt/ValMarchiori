# Implantação de Aplicativo Next.js com Docker Swarm e Traefik

Antes de começar, aqui está um resumo do que vamos fazer: preparar seu aplicativo Next.js para Docker, criar um Dockerfile otimizado, configurar um arquivo de stack para Docker Swarm e implantá-lo usando Portainer com a integração do Traefik já existente na sua VPS.

## Preparando seu Aplicativo Next.js para Dockerização

Primeiro, precisamos preparar seu aplicativo Next.js para ser executado em um contêiner Docker. Vamos começar fazendo algumas configurações no projeto:

### 1. Configure o Next.js para modo standalone

Abra o arquivo `next.config.js` e adicione a configuração de output "standalone":

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone'
}

module.exports = nextConfig
```

Esta configuração é crucial pois otimiza o aplicativo Next.js para ambientes em contêineres, reduzindo o tamanho da imagem Docker[1][7].

### 2. Crie um arquivo .dockerignore

Crie um arquivo `.dockerignore` na raiz do projeto com o seguinte conteúdo:

```
.env
Dockerfile
.dockerignore
node_modules
npm-debug.log
README.md
.next
.git
```

Este arquivo evita que arquivos desnecessários sejam copiados para a imagem Docker, tornando-a mais leve e segura[6][15].

## Criação do Dockerfile

Agora, vamos criar um Dockerfile otimizado usando uma abordagem multi-estágio para reduzir o tamanho final da imagem:

```dockerfile
# syntax=docker.io/docker/dockerfile:1

# Estágio base para compartilhar configurações
FROM node:18-alpine AS base
WORKDIR /app
ENV NEXT_TELEMETRY_DISABLED=1

# Estágio para instalar dependências
FROM base AS deps
RUN apk add --no-cache libc6-compat
COPY package.json package-lock.json* ./
RUN npm ci

# Estágio para construção
FROM base AS builder
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

# Estágio final
FROM base AS runner
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# Define o diretório para os arquivos standalone
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs
EXPOSE 3000
ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

Este Dockerfile segue as melhores práticas para aplicações Next.js em produção, incluindo:
- Uso de multi-estágio para reduzir o tamanho final da imagem
- Execução como usuário não-root para maior segurança
- Configuração adequada para o modo standalone do Next.js[8][12][18]

## Configuração da Stack para Docker Swarm

Agora, vamos criar um arquivo de configuração de stack para o Docker Swarm. Crie um arquivo chamado `nextapp-stack.yml`:

```yaml
version: '3.8'

services:
  nextapp:
    image: ${IMAGE:-nextapp:latest}  # Você pode substituir por um registro, se tiver
    build:
      context: .
      dockerfile: Dockerfile
    deploy:
      replicas: 2
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.nextapp.rule=Host(`sua-app.seu-dominio.com`)"
        - "traefik.http.services.nextapp.loadbalancer.server.port=3000"
        - "traefik.http.routers.nextapp.entrypoints=websecure"
        - "traefik.http.routers.nextapp.tls=true"
    networks:
      - traefik-net  # Substitua pelo nome da sua rede do Traefik

networks:
  traefik-net:
    external: true  # Isso permite conectar à rede existente do Traefik
```

Este arquivo configura uma stack que:
- Usa o Dockerfile para construir a imagem (ou uma imagem pré-construída)
- Configura 2 réplicas do serviço para disponibilidade
- Configura as labels necessárias para o Traefik rotear o tráfego corretamente
- Conecta o serviço à rede existente do Traefik[5][16][19]

## Implantação com Portainer

Agora que você tem os arquivos configurados, pode implantá-los usando o Portainer:

1. **Acesse o Portainer** - Entre no painel do Portainer através do navegador (normalmente em `https://portainer.seu-dominio.com`)

2. **Adicione uma nova stack**:
   - No menu lateral, clique em "Stacks"
   - Clique no botão "+ Add stack"
   - Dê um nome para sua stack (por exemplo, "nextapp")

3. **Método de implantação**:
   - Você tem duas opções:
     - Fazer upload dos arquivos do projeto e indicar o caminho para o Dockerfile
     - Colar diretamente o conteúdo do arquivo YAML no campo "Web editor"

4. **Configurações adicionais**:
   - Se for necessário, defina variáveis de ambiente específicas
   - Verifique se a rede externa está corretamente configurada

5. **Deploy the stack** - Clique no botão para implantar a stack e aguarde a conclusão[10][14][17]

## Considerações importantes

1. **Nome da rede Traefik**: Certifique-se de substituir `traefik-net` pelo nome real da rede que o Traefik usa na sua VPS.

2. **Domínio**: Substitua `sua-app.seu-dominio.com` pelo domínio que você deseja usar para acessar seu aplicativo.

3. **DNS**: Configure o registro DNS para o novo domínio apontando para o IP da sua VPS, assim como foi feito para outros serviços.

4. **Volume para persistência**: Se seu aplicativo precisar de persistência de dados, considere adicionar volumes à configuração.

5. **Ambiente de produção**: Certifique-se de que as variáveis de ambiente necessárias para seu aplicativo estejam configuradas corretamente na stack.

Mesmo que você não saiba codificar (como mencionou que a IDE "WinSuck" faz o código para você), estas instruções detalhadas devem permitir que você configure corretamente a implantação do seu aplicativo Next.js no Docker Swarm com Traefik[2][5][16].

## Solução de problemas

Se encontrar problemas após a implantação:

1. **Verificar logs** - No Portainer, você pode verificar os logs dos contêineres
2. **Verificar conectividade da rede** - Certifique-se de que a rede Traefik está corretamente configurada
3. **Verificar labels** - As labels do Traefik são sensíveis a erros de digitação
4. **Verifique se o DNS está apontando corretamente** - Use ferramentas como `nslookup` para garantir que o domínio está apontando para o IP correto da VPS
